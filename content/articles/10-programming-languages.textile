----- 
popular: true
summary: "A quick comparison of 10 non-mainstream programming languages, highlighting their main features, pros and cons. Each section contains also a list of links to get you started with a particular language."
permalink: 10-programming-languages
filters_pre: 
- redcloth
title: 10 programming languages worth checking out
comments: 
- :date: 
  :author: Nikhil
  :url: http://kodeclutz.blogspot.com
  :id: 2593
  :body: Great list. It's good to see factor getting more and more publicity, although I haven't 'got' it yet.
- :date: 
  :author: Dmitriy Kopylenko
  :url: http://grailscrowd.com/members/dima767
  :id: 2594
  :body: No mention of Groovy. Sad... :-(
- :date: 
  :author: Dmitriy Kopylenko
  :url: http://grailscrowd.com/members/dima767
  :id: 2595
  :body: On the other hand one might consider Groovy 'mainstream' and not so 'esoteric'
- :date: 
  :author: James
  :url: http://jamesconroyfinn.com
  :id: 2596
  :body: Great article. I was hoping to see Brainfuck and Whitespace. ;)
- :date: 
  :author: Foo
  :url: ""
  :id: 2598
  :body: |-
    I like to think of Groovy as "poorly conceived".  The slowness of Ruby without the elegance.
    
    Here's the least smart piece of text in the piece:  "Unlike other Lisps (and Schemes) you may have encountered before, Clojure comes with some interesting additions:"
    
    Um... Common Lisp has two of those (data types, multimethods), and the other two are trivially added with macros.  Clojure's cute, sort of, but Common Lisp is where most of the momentum is.
- :date: 
  :author: Walter Bright
  :url: http://www.digitalmars.com/d/
  :id: 2599
  :body: One can also consider the D programming language, http://www.digitalmars.com/d, which is a modern systems programming language.
- :date: 
  :author: Chris Papadopoulos
  :url: http://informationrain.com/
  :id: 2600
  :body: |+
    I've had a lot of fun lately playing around with Processing and would mention it as an alternative to programmers who want something fun to escape their normal work. Also, learning to problem solve in a visual environment instead of working with things like databases can be very stimulating.
    
    http://processing.org/
    
    
- :date: 
  :author: Mitch
  :url: http://softwareindustrialization.com
  :id: 2601
  :body: What do you think of F#?
- :date: 
  :author: Tim Locke
  :url: ""
  :id: 2602
  :body: "Another interesting project written in Smalltalk is Scratch: http://scratch.mit.edu/"
- :date: 
  :author: Michael
  :url: http://videotree.blogspot.com
  :id: 2603
  :body: "Have a look at newLisp -- Lisp as a lighter weight scripting language. "
- :date: 
  :author: Jeff
  :url: ""
  :id: 2604
  :body: |
    REBOL should be on the list. http://www.rebol.com/
    
    Otherwise, it is a great list. My only real disappointment is that the "newer" versions of old standby languages are there in place of the goodies. Factor vs. Forth, Clojure vs. Lisp. While those new incarnations might breath new life into the old, I can almost guarantee that Factor will fade away, but good ol' Forth will still be around.
    
    Also, if you were going to put a Forth language on the list that wasn't ANS Forth, I'd have put Colorforth up there (http://www.colorforth.com/cf.html) - as least that one is made by the inventor of Forth. ;-)

- :date: 
  :author: Brian
  :url: http://htdp.org/
  :id: 2607
  :body: |-
    Another great resource for PLT Scheme is the book How to Design Programs. Its free online at http://htdp.org/
    
    My Computer Science Fundamentals class at northeastern university used PLT Scheme and that was the book which was used to teach not just the language but good design practices.
    
    I definitely recommend you check it out.
- :date: 
  :author: mgroves
  :url: http://www.mgroves.com
  :id: 2608
  :body: Interesting that you mention C# 1 time, and never mention VB, even though those are two languages that "pay the bills" for many, many programmers.
- :date: 
  :author: WebGlad
  :url: http://www.webglad.com/
  :id: 2610
  :body: "Really good article. I liked this statement:\n\n\
    \xE2\x80\x9CThe most obvious common \xE2\x80\x98personality\xE2\x80\x99 characteristics of hackers are high intelligence, consuming curiosity, and facility with intellectual abstractions.\"\n\n\
    While I don't consider myself to be a hacker, I have a curiosity that I can't hamper. Sometimes it works to the detriment of my productivity. Still, it does lead me to explore articles like yours."
- :date: 
  :author: chomotus
  :url: http://www.google.com
  :id: 2611
  :body: for me J has no competition as a functional language..
- :date: 
  :author: Ed Borasky
  :url: ""
  :id: 2614
  :body: "Most of us programmers fall into the class \"specially if 500 developers in your company already develop in C# and you don\xE2\x80\x99t, as a matter of fact, have a saying on the matter.\" A programming language needs a *compelling* advantage over the more general and widely-used ones in order to be worth studying for most of us.\n\n\
    And I find the argument that learning another language makes you a better programmer somewhat flawed. It's more the other way around -- really good programmers find it easy to learn the semantics of programming languages."
- :date: 
  :author: Elmer
  :url: ""
  :id: 2617
  :body: |-
    Revolution: Is a must on this list!    http://www.runrev.com
    
    Revolution is a programming environment you can quickly understand. Achieve immediate results with a visual, drag-and-drop interface builder. Use English, the language you already know, to describe program logic. Deploy powerful cross-platform solutions without the huge learning curve of other development environments.
    
    http://www.runrev.com
- :date: 
  :author: Glad_if_I
  :url: ""
  :id: 2623
  :body: |-
    When you wrote that Haskell's has "Speed that rivals C and <notextile>C++</notextile>" I looked at the link that you provided and it proved you wrong.  That is to say it stated that in computer processing that both C and <notextile>C++</notextile> is processes faster.  While it stated that in some instances it beat C++ it did suggest that if optimization was a factor you had better write the program in C.  The speed it talked about in the article was how fast it was for the programmer to write the code in Haskell than in C and <notextile>C++</notextile>.  
    
    Now if you had stated:
    "The Speed at which it takes to program something in Haskell rivals that of C and <notextile>C++.</notextile>"
    
    I would be okay with that but the way you stated it was misleading.  It was a lie.  I am not trying to be mean but when you talk about programming speed that means how fast the computer processes.  Each programmer creates and edits code at their own speed.  It is a subjective property of each programmer.  Maybe it is easier to program in Haskell and thus faster supposedly.  But the way you wrote it was misleading.
    
    C is the fastest language for a reason.  Because it is one step above assembler which in turn is faster than C.  If you are going to make statements that are a lie.  Do not link to a page that disagrees with you.
- :date: 
  :author: pRtkL xLr8r
  :url: http://www.deadpumpkin.com
  :id: 2624
  :body: Why on earth isn't QuickBasic on this list???
- :date: 
  :author: Mark Stock
  :url: http://machete-lang.blogspot.com/
  :id: 2625
  :body: |-
    No mention of my _fill_in_the_blank_ language!  :(
    
    ;)
- :date: 
  :author: sam
  :url: http://www.skyfly-travels.com
  :id: 2626
  :body: |
    Really good article. I liked this.

- :date: 
  :author: sam
  :url: http://www.skyfly-travels.com
  :id: 2627
  :body: |
    Really good one

- :date: 
  :author: Christian
  :url: ""
  :id: 2630
  :body: |-
    You may want to take a look at PowerShell. Focused on Administration of IT, but able to do so much more. 
    
    http://www.microsoft.com/windowsserver2003/technologies/management/powershell/default.mspx
    
    http://blogs.msdn.com/powershell/
- :date: 
  :author: BK
  :url: http://puppylinux.com
  :id: 2632
  :body: |
    Here's another, Genie (and Vala):
    
    http://puppylinux.com/genie

- :date: 
  :author: Oliver
  :url: ""
  :id: 2635
  :body: |-
    I'd second the mention of J above. I'm only starting out on it, but it's very satisfying how your initial bewilderment of the program text turns into comprehension relatively quickly.
    
    My language <i>du jour</i> is Mozart/Oz (http://www.mozart-oz.org). Mozart made me get to grips with Emacs just to play with the Oz Programmer's Interface (Oz is a virtual machine Mozart runs on).
- :date: 
  :author: Andreas Schipplock
  :url: http://schipplock.de
  :id: 2636
  :body: And what about Ada 2005? Ada is breathing! :)
- :date: 
  :author: clj
  :url: ""
  :id: 2637
  :body: "Alright, you've just motivated me to write the critique of Clojure (+ the annoyance with the (background) FUD against Java that sometimes accompanies Clojure.)  "
- :date: 
  :author: Dave
  :url: http://www.davidrware.com
  :id: 2640
  :body: Very awesome article! I'm on Christmas vacation and was bored, looking for something to occupy my time and now I think I found something to. Thanks for the great read and hours of amusement.
- :date: 
  :author: Ulf Wiger
  :url: http://ulf.wiger.net/weblog
  :id: 2641
  :body: |
    Damien Katz' article is indeed an interesting read, but it mainly addresses those already sold on Erlang. Others might perhaps first want to read http://sdtimes.com/link/33124, in which Katz explains how he threw away his <notextile>C++</notextile> based CouchDB after having played around with Erlang for a week, and then rewrote in 1.5 months what had taken him 6 months to write in <notextile>C++</notextile>. Otherwise, one could easily get the impression that Katz isn't very fond of Erlang... ;-)

- :date: 
  :author: Phil
  :url: http://technomancy.us
  :id: 2647
  :body: "> Foo: Um\xE2\x80\xA6 Common Lisp has two of those (data types, multimethods), and the other two are trivially added with macros. Clojure\xE2\x80\x99s cute, sort of, but Common Lisp is where most of the momentum is.\n\n\
    Common Lisp's non-list compound data types are crippled because they're not composable in the same way lists are. Furthermore, only vectors have syntax literals, making the rest a huge pain do deal with. Clojure's biggest innovation was making it so you could start writing your program with lists, then swap in a more appropriate data structure for perf later without modifying any of your code.\n\n\
    Common Lisp has a lot of things, but momentum is not one of them."
- :date: 
  :author: PatzZ
  :url: http://tutorial-net.blogspot.com/
  :id: 2651
  :body: hey you changed my mind i'll look into those future thanks
- :date: 
  :author: JeGX
  :url: http://www.geeks3d.com
  :id: 2665
  :body: |-
    Nice overview!
    Another programming/scripting language is <a href="http://squirrel-lang.org">Squirrel</a>. And here is a tool to play with Lua: <a href="http://www.ozone3d.net/demoniak3d/">Demoniak3D</a>.
- :date: 
  :author: Dan
  :url: http://mayerdan.com
  :id: 2678
  :body: Learning a new language is on my list as well, good list keep it up.
- :date: 
  :author: Michael
  :url: ""
  :id: 2679
  :body: What about the greatest and most serious language out there? LOLcode was totaly forgotten in this article.
- :date: 
  :author: Napolux
  :url: http://www.napolux.com
  :id: 2680
  :body: Well. If squeak is here I want also LOLcode.
- :date: 
  :author: botchagalupe
  :url: http://johnmwillis.com
  :id: 2681
  :body: Great post...
- :date: 
  :author: w43L
  :url: http://blog.w43l.com
  :id: 2682
  :body: "nice article, but who have time for learning of these languages\n\n\
    :("
- :date: 
  :author: e
  :url: ""
  :id: 2686
  :body: |+
    yeah, leaving off J?  The J community is like a parallel universe where they are quietly going about their own thing . . . undaunted by the rest of the world.  You download it.  You get an IDE, training materials, tons of examples, tutorials . . .access to all kinds of free, whole, books.  You can make GUIs and games and 3D stuff ...
    
    I want to freeze time and spend like two or three uninterrupted years on J. You don't even need parameters if you don't want.  Want to operate on whole matrices?  Go ahead.  insanely beautiful plots?  http://www.jsoftware.com/
    
    Also get ready for something amazing and quite entertaining at the same time in Frink: http://futureboy.homeip.net/frinkdocs/  I won't spoil the surprise.
    
    Try Joy to see how simple it can get, especially to get a taste of the theory.
    
    Clean is supposed to be fast, fast fast.
    
    
    
- :date: 
  :author: Bertrand
  :url: ""
  :id: 2687
  :body: <a href="http://svn.apache.org/viewvc/httpd/httpd/trunk/modules/lua/">mod_lua</a> coming to an apache server near you.
- :date: 
  :author: Etienne
  :url: http://madariaga.wordpress.com
  :id: 2688
  :body: |-
    Nice article. 
    
    One of the things I find useful when looking for a new language to learn, is having a quick glance at its syntax. I know if I don't like how its code _looks_ I won't like the language. If I am interested by it, I might give some more insight to a particular language.
- :date: 
  :author: David
  :url: http://www.autohotkey.com
  :id: 2689
  :body: I think you missed Autohotkey.com which is excellent for its purpose.
- :date: 
  :author: Astor
  :url: ""
  :id: 2693
  :body: "Even if it's not really a \"functionnal paradigm oriented\" programming language, you should definitively take a look at \"the D programming language\" : http://www.digitalmars.com/d/ . It kind of tries to compell with C/C++ for system programming (yep inline assembly code is possible), but also offer some nice features as far as concurrency is concerned, like \"pure\" keyword for functions or shared/unshared global state for multithreaded operations."
- :date: 
  :author: MAK
  :url: ""
  :id: 2707
  :body: |-
    Hello, I wanted to communicate with you via email, but the email link on your floating menu uses a mailto mechanism and since I'm under OpenBSD with no mailto link set in Firefox, I'm unable to get through to you (I even tried viewing source :-)
    
    Could you please write back to me on the email address mentioned in this post?
    
    Thanks.
date: 2008-12-21 15:01:15 +01:00
tags: 
- programming
type: article
toc: true
-----
If you program for fun or profit, chances are that you know C, C++, Java, PHP, Perl, Python or Ruby. These programming languages are all widely known, and, to a different degree, used in commercial applications. At least some of them can safely be considered _mainstream_, even if that word has become so overused and misused that has almost lost its original meaning, if it ever had one.

If you are earning your living by coding, it's often one of these languages that pays the bills. Nevertheless, true hackers frequently meander in other directions, exploring and discovering different paradigms and methodologies, sometimes to the most ["esoteric":http://esolangs.org/wiki/Main_Page] extremes.

bq. "The most obvious common 'personality' characteristics of hackers are high intelligence, consuming curiosity, and facility with intellectual abstractions. Also, most hackers are 'neophiles', stimulated by and appreciative of novelty (especially intellectual novelty). Most are also relatively individualistic and anti-conformist."

p((((. &ndash; Eric S. Raymond, ??"The Jargon File":http://catb.org/jargon/html/personality.html?? 

Even if you're particularly devoted to one of the languages mentioned above, it is normal to be curious about what else is out there. As the end of the year approaches, I find myself thinking about learning &ndash; or at least become acquainted with &ndash; some less known, more experimental, programming languages.
I was originally planning on learning another programming language as a New Year's Resolution, which is quite common among programmers. The most difficult task turned out to be _choosing_ a particular language: there are so many out there which makes it very hard to decide.

This article deals with ten possible candidates, and it's far from being an exhaustive list. The programming languages described henceforth are very different from each other, but they all have one thing in common: they all stimulate my curiosity in their own, very different ways.

h3(#haskell). Haskell

I tried to learn Haskell in the past. Quietly, I started diving into the multitude of articles, tutorials, overviews and even books about this fascinating academic language which claims to achieve functional purity though remaining extremely useful, practical and efficient. Sadly, I'm still not able to fully grasp some of its most crucial concepts, such as "monads":http://en.wikibooks.org/wiki/Programming:Haskell_monads, but this still doesn't put me off _wishing_ to learn the language.

If you've never enountered Haskell before, I find "The Evolution of a Haskell Programmer":http://www.willamette.edu/~fruehr/haskell/evolution.html an amusing and informative read. Although aiming to be humorous in a way, it serves a very important didascalic purpose: it is one of the most complete collections of the different paradigms and programming approaches Haskell allows.

Besides its very elegant, pragmatic and almost-magical syntax, what really intrigues me about this language is what it offers, in terms of features:

* 9 different "implementations":http://www.haskell.org/haskellwiki/Implementations (multiple compilers _and_ interpreters)
* Countless "standard libraries":http://haskell.org/ghc/docs/latest/html/libraries/ "packages":http://hackage.haskell.org/packages/archive/pkg-list.html which can be used to solve _any_ programming challenge
* Abundant "learning material":http://www.haskell.org/haskellwiki/Books_and_tutorials
* "Speed":http://www.haskell.org/haskellwiki/Why_Haskell_matters#The_speed_of_Haskell that rivals C and C++
* Very mature cross-platform compatibility

The catch? It is likely to be very different from any other language you might have encountered before, and that's probably the reason why some people find it difficult to learn and master. That being said, if you are looking for a challenging (but very rewarding, I believe) New Year's Resolution, you should definitely go for this.

h4. To get you started...

* "Official Haskell Wiki":http://www.haskell.org/
* "Haskell Wikibook":http://en.wikibooks.org/wiki/Haskell
* "Real World Haskell":http://book.realworldhaskell.org/read/index.html
* "37 Reasons to Love Haskell":http://cdsmith.wordpress.com/2007/07/29/37-reasons-to-love-haskell-playing-off-the-ruby-article/
* "Haskell for the Ruby Guy":http://antoniocangiano.com/2007/03/13/haskell-eye-for-the-ruby-guy/
* "A-Z of Programming Languages: Haskell":http://www.techworld.com.au/article/261007/-z_programming_languages_haskell
* "Learn you a Haskell for Great Good!":http://learnyouahaskell.com/
* "Haskell Hacking":http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16

h3. Erlang

"Erlang":http://erlang.org/ is a concurrent programming language originally developed by Ericsson for their real-time applications. It goes without saying that with these premise, Erlang seems the most natural answer to all concurrency problems you may encounter in your life as a programmer.
Developing with concurrency in mind feels natural and easy in Erlang, and the performance of Erlang-powered systems can be unmatched.

Quite a few interesting applications have been developed in this language, such as:

* "CouchDB":http://couchdb.apache.org/, a popular distributed, document-oriented database
* "Yaws":http://yaws.hyber.org/, a high-performance web server
* even "Facebook Chat":http://www.facebook.com/note.php?note_id=14218138919&id=9445547199

The price Erlang adepts have to pay, as Damien Katz (CouchDB creator and Erlang enthusiast) "points out":http://damienkatz.net/2008/03/what_sucks_abou.html, is:

* Awkward syntax, inspired by Prolog
* Weird if expressions
* Difficult string operations
* No classes or namespaces

...this list could go on. Damien's article is an interesting read, enough to put anyone off learning the language if read superficially. On the other hand, it provides an invaluable resource for newcomers who wish to be prepared before taking on the challenge of learning Erlang to build their next scalable, concurrent and industry-proof application.

h4. To get you started...

* "Official Erlang Web Site":http://www.erlang.org/
* "An Introduction to Erlang":http://www.onlamp.com/pub/a/onlamp/2007/09/13/introduction-to-erlang.html
* "Erlang Style Concurrency":http://www.defmacro.org/ramblings/concurrency.html
* "PlanetErlang":http://www.planeterlang.org/
* "Erlang Projects":http://www.erlang-projects.org/

h3(#io). Io

"Io":http://iolanguage.com/ is a relatively new programming language by Steve Dekorte which recently surfaced from Google's oblivion (if you tried googling for it a few months ago, you couldn't event find its home page) thanks to a short vut stimulating "article":http://hackety.org/2008/01/05/ioHasAVeryCleanMirror.html by "_why":http://whytheluckystiff.net/. It doesn't have the best name for a programming language, that's for sure, but it's definitely a breath of fresh air in terms of the way it works.

Its unusual, minimalist and yet elegant and powerful syntax reminds of Smalltalk, but the language goes far beyond that. Io is an object-oriented, prototype-based, message-based and fully-reflective programming language. This means that you use messages like in Smalltalk, you create objects like in Javascript and every bit of your code can be inspected and passed around as you see fit.

If you think Ruby allows fancy (and potentially dirty) tricks like metaprogramming and monkey-patching, Io takes this to a whole different level, imposing virtually no limitation to the programmer. What's truly amazing is that its grammar and syntax are so minimal that you can learn them in literally 10 minutes. After that, you can start experimenting, first with its extremely small core and then with its extension libraries and bindings.

Io has indeed a lot of potential. Granted, it's still young and under development, but also already quite efficient and suitable for real-world tasks demanding high speed and concurrency. It is implemented in C, but Ola Bini started to design a similar language called "Ioke":http://kenai.com/projects/ioke/ for the Java Virtual Machine.

h4. To get you started...

* "Official Io Web Site":http://iolanguage.com/
* "Io Repository on Github":http://github.com/stevedekorte/io/tree/master
* "Io user group":http://tech.groups.yahoo.com/group/iolanguage/
* "Io has a very clean mirror":http://hackety.org/2008/01/05/ioHasAVeryCleanMirror.html
* "Io Notes":http://iota.flowsnake.org/
* "Io Language Notes":http://wiki.type-z.org/index.php/Io/IoLanguage
* "Blame it on Io! A slow-paced introduction to the Io language":http://ozone.wordpress.com/2006/03/15/blame-it-on-io/
* "Io Wikibook":http://en.wikibooks.org/wiki/Programming:Io

h3(#plt-scheme). PLT Scheme

I stumbled upon the "PLT Scheme web site":http://plt-scheme.org/ while browsing for different Lisp flavors about a year ago. At the time, I was determined to learn the rudiments of Lisp and I started reading a few articles and books on this old and yet still popular language.
Although I was originally put off by certain Common Lisp literature, which dismissed Scheme as an almost-heretic attempt to revitalize an venerable language, I soon found out that Scheme &ndash; and PLT Scheme in particular &ndash; is definitely worthy of attention and interest.

Being a technical writer, I immediately became fond of the "PLT Scheme Guide":http://docs.plt-scheme.org/guide/, one of the clearest and most well-organized examples of documentation available for a programming language I've ever come across.
The manual is exquisitely crafted  as a Getting Started Manual and a Reference Book at the same time, though remaining pleasant to read sequentially: a rare trait in technical documentation. Best of all, it's free: you simply have no real excuse not to read it.

Besides its excellent documentation, PLT Scheme feels like a fresh and modern implementation of one of the two most important dialects of Lisp. It's cross-platform, it has an extensive "collection of packages":http://planet.plt-scheme.org/ and a very active community behind it. 
After my first attempt to learn Haskell, I felt compelled to try out PLT Scheme and it immediately felt much easier and more user friendly to learn, partly because of "DrScheme":http://download.plt-scheme.org/drscheme/ a dedicated IDE/learning tool optimized to get you started and feel comfortable with the language.
Caveats? None, unless you have an adversion for parenthesis, that is.

h4. To get you started...

* "Official PLT Scheme Web Site":http://plt-scheme.org/
* "PLT Scheme Guide":http://docs.plt-scheme.org/guide/index.html
* "PLaneT":http://planet.plt-scheme.org/
* "Quick: An Introduction to PLT Scheme with Pictures":http://docs.plt-scheme.org/quick/
* "More: Systems Programming with PLT Scheme":http://docs.plt-scheme.org/more/

h3(#clojure). Clojure

"Clojure":http://clojure.org/ is the most recent and notable attempt to bring Lisp back to life and ready to face the challenges posed to IT systems by the new century: concurrency and scalability. Because it runs on the Java Virtual Machine, you also get Java interoperability for free, in a more Lispy flavour. Although I'm a bit reluctant to deal with anything related to Java nowadays, Clojure's approach makes it more appealing.

Unlike other Lisps (and Schemes) you may have encountered before, Clojure comes with some interesting additions:

* "Multimethods":http://clojure.org/multimethods
* "Agents asynchronous actions":http://clojure.org/agents
* Some interestings "special forms":http://clojure.org/special_forms
* Many pre-built "data structures":http://clojure.org/data_structures, like Vectors, Maps, Sets, Collections, ...

Despite all this, Rich Hickey became increasingly popular both in the Lisp and Java world for creating such an interesting and well-designed language. Unlike with many new (and old) programming languages, I have yet to find a single blog post or article which is seriously criticizing Clojure in any way.

h4. To get you started...

* "Official Clojure Web Site":http://clojure.org
* "Clojure User Group":http://groups.google.com/group/clojure
* "Clojure presentation on InfoQ":http://www.infoq.com/presentations/hickey-clojure
* "Trying Clojure":http://netzhansa.blogspot.com/2008/10/trying-clojure.html
* "My first look at Clojure":http://groups.google.com/group/clojure/msg/f038decc18c7da37
* "Enclojure":http://enclojure.net/Index.html

h3(#squeak). Squeak

"Squeak":http://www.squeak.org/ has become one of the most popular Smalltalk implementations available. It has been used in some very interesting projects:

* "EToys":http://wiki.laptop.org/go/Smalltalk_Development_on_XO, a kids-oriented but powerful development environment built in Squeak, was included as part of the educational sofware suite of the "OLPC":http://www.laptop.org.
* "Seaside":http://www.seaside.st/ is a modern and very productive web framework running on Squeak.
* "Croquet":http://www.croquetproject.org/index.php/Main_Page is a development solution to build complex, multi-user virtual worlds.

If you ask "Randal Schwartz":http://www.stonehenge.com/merlyn/, he'll explain you "why":http://www.infoq.com/articles/smalltalk-comeback-schwartz Squeak and Smalltalk are at least worth a look. Personally, while I'm attracted by Smalltalk's unique approach to programming and its friendly syntax, I am still a bit overwhelmed by the way it works. 
Squeak, and Smalltalk in general, runs inside (literally) a virtual machine written in Squeak itself. This means that:

* You write your code inside Squeak
* You debug, inspect and interact your code inside squeak
* You run your code inside Squeak
* You can install Squeak on virtually any platform, including mobile phones, fairly easily

Everything lives inside Squeak. It's very weird to picture this without actually trying it, so I suggest you "download it":http://www.squeak.org/Download/ and give it a try: it will definitely be an unusual but intriguing experience.

Smalltalk takes programming to a whole different level, which is simply unimaginable for other languages. In return, it asks you to fully embrace the Smalltalk way of doing things, according to which external text editors, external version control systems and other common tools familiar to traditional programmers simply loose their purpose.

h4. To get you started...

* "Official Squeak Web Site":http://www.squeak.org/
* "Squeak by Example":http://squeakbyexample.org/
* "SqueakLand":http://www.squeakland.org/
* "Ruby's Roots: Smalltalk Comeback and Randal Schwartz on Smalltalk":http://www.infoq.com/articles/smalltalk-comeback-schwartz
* "FLOSS Weekly 29: Dan Ingalls":http://twit.tv/floss29

h3(#ocaml). OCaml

Like Smalltalk, "OCaml":http://caml.inria.fr/ has been getting more attention recently than in the past. Sure, not everyone is planning to learn is these days, but after reading "this article":http://enfranchisedmind.com/blog/2008/04/14/useful-things-about-static-typing/ I admit I was eager to give it a proper try.

Despite being statically typed, OCaml offers some of the features which are common in dynamically typed languages like Ruby, such as duck typing, the possibility of creating Domain-Specific Languages and even extending the language syntax with custom operators and constructs.

Additionally, the  "OCaml Batteries Included":http://batteries.forge.ocamlcore.org/ project was created as an attempt to bundle a standard set of commonly-used library together with the language core. Even if this project is still in alpha stage, it definitely "looks promising":http://dutherenverseauborddelatable.wordpress.com/2008/11/07/a-taste-of-ocaml-batteries-included/.

h4. To get you started...

* "Official Caml Web Site":http://caml.inria.fr/
* "Objective Caml Tutorial":http://www.ocaml-tutorial.org/
* "A Concise Introduction to Objective Caml":http://www.csc.villanova.edu/~dmatusze/resources/ocaml/ocaml.html
* "The OCaml Alliance Network":http://wiki.cocan.org/
* "OCaml News":http://ocamlnews.blogspot.com/
* "OCaml Batteries Included":http://batteries.forge.ocamlcore.org/

h3. Factor

"Factor":http://factorcode.org/ is to Forth what "Clojure":http://clojure.org is to Common Lisp: a reincarnation of an ancient language in a more modern and practical form. In the specific case, although it borrows from Lisp and Self as well, Factor retains the main characteristics of its ancestor: it's stack-based, concatenative and has postfix notation.
While this is enough to put some people off, if you digg deeper you'll discover that Factor offers all the most important features available in contemporary programming languages: garbage collection, dynamic typing, an object system, ... they're just presented in a very different way:

bq. "Learning Factor is tough. One reason for this is that Factor is very different from other programming languages. Programmers today are used to imperative programming languages where data is stored and passed around in named variables (or function calls, which name their variables). Factor is the opposite of this. A lot of code tends to be written in a functional style, and even more jarringly, variables are rare, only referenced in a small fraction of words. Nobody intends to change any of this; it's a feature, not a bug!"

p(((. &ndash; Daniel Ehrenberg, ??"Learning Factor":http://useless-factor.blogspot.com/2008/01/learning-factor.html??

Like Haskell, Factor demands a completely different programming approach to what you may be used to, but once you get past that, it can be as useful as any other language, if not more. The "Furnace":http://docs.factorcode.org/content/article-furnace.html web framework, which powers the "Concatenative":http://concatenative.org/ wiki, is entirely built in Factor and runs on top of a Factor web server.

h4. To get you started...

* "Official Factor Web Site":http://factorcode.org/
* "Factor on the Concatenative Wiki":http://concatenative.org/wiki/view/Factor
* "Factor Documentation":http://docs.factorcode.org/
* "Learn Factor":http://learnfactor.org/
* "Planet Factor":http://planet.factorcode.org/

h3(#lua). Lua

"Lua":http://www.lua.org/ ("Moon" in Portuguese), is a lightweight and fast scripting language which can be easily embedded in other systems. Compared to the other languages mentioned in this article, it is definitely the less alien of the lot: if you know a tiny bit of C or Java, you'll be able to understand (and possibly write) 80% of Lua code without reading a single line of its documentation. 

Despite its simplicity, Lua is considered a multi-paradigm language supporting imperative, functional and even object-oriented approaches. More specifically, Lua's _tables_ provide a simple but powerful way to create arrays, hashes and even classes (or better, prototypes). Simple (and multiple) inheritance is achieved through _metatables_, which allow calls to undefined functions to be _transferred_ to parent tables.

Lua programs are not interpreted in the traditional way: they are compiled to bytecode and then executed in the Lua Virtual Machine. As a result, Lua code tends to be executed much faster than other interpreted languages, so fast that "as fast as Lua" has become a proverbial expression.
Lua found its niche in embedded applications and games development, basically everywhere there's the need to provide a fast scripting language which is also very easy to learn and extend with C or other languages.

h4. To get you started...

* "Official Lua Web Site":http://www.lua.org/
* "Lua Manual":http://www.lua.org/manual/
* "Lua-users":http://lua-users.org/
* "Learning Lua":http://icculus.org/~theoddone33/lua/
* "Lua for Beginners":http://lua.gts-stolberg.de/en/index.php?uml=1

h3(#scala). Scala

You may not be happy to see "Scala":http://www.scala-lang.org/ in this list instead of other very valid and equally powerful languages for the Java Virtual Machine such as "Groovy":http://groovy.codehaus.org/. While there was no doubt on whether Clojure should have been included or not, I was a bit hesitant to include Scala. In the end, I chose to do so simply because Scala fits better in this list than other languages: as you should have noticed by now, I am somehow more inclined to learn functional languages as opposed to their object-oriented counterparts.

Scala is both object oriented and functional. It offers the best of both worlds: classes, traits and mixins which may be familiar to OOP lovers but also anonymous functions, currying and pattern matching which may please Haskell enthusiasts. Additionally, it's also compatible with Java: so if you use Java for work, trying out Scala for pleasure is definitely the most logical next step, especially if you want to experiment with functional programming in the meantime.

Compared to learning a fully-functional (no pun intended) language like Haskell, Clojure or PLT Scheme, learning Scala is definitely easier and will feel less alien.

h4. To get you started...

* "Official Scala Web Site":http://www.scala-lang.org/
* "The Case for Scala":http://blogs.zdnet.com/Burnette/?p=690
* "Scala Wiki":http://scala.sygneca.com/
* "Learning Scala with Project Euler":http://grok-code.com/75/learning-scala-with-project-euler/
* "Roundup: Scala for Java Refugees":http://www.codecommit.com/blog/scala/roundup-scala-for-java-refugees

h3. Epilogue

There are so many interesting programming language out there that it's very hard to keep track of all of them. I hope this list can aid you in the right direction, whichever it may be. 
Some people may debate over the very essence of this article: why _choosing_ a programming language? Why spending time and energy in a task which may lead to a lot of confusion in your mind and lead you nowhere? What's the purpose of learning something which may feel totally alien to you?

A programming language is ultimately just a tool to get your job done. If you have to write an end-user, desktop GUI application which will always run on Windows and which needs to inteface with Microsoft technologies, you'll choose C# over Haskell, there's no doubt about that. Especially if 500 developers in your company already develop in C# and you don't, as a matter of fact, have a saying on the matter.

But what if you _could_ choose? What if you wanted to develop your own geeky command line application to automate a particular task for yourself, and not because someone else tells you to do so? Would you be willing to experiment with something totally different and potentially difficult just for the sake of learning new things?

If the answer is yes, then you should take a look at this list again. Not now, maybe not this month or this year, but when you feel the time is right, and give one of these languages a shot. It may not end well (so far I attempted to learn Haskell twice, with no luck), but I promise you it will be worthwhile, in the long run. 
If you already mastered some of these languages already, or even all of them, be assured that they're plenty out there ready to be discovered and open your mind even more. Or, if you prefer, there are a lot of minds out there which may need guidance in learning and discovery. Help them. Write articles, tutorials, books, educate and evangelize: ultimately, that will be your greatest reward.
