'hastysite import

() =TAGS
() =TAGCOLUMNS
() =ARCHIVES


; Populates the TAGCOLUMNS array containing tags in groups
; of four, suitable for the creation of the tags page.
(
  TAGS dsort =TAGS
  0 :count
  () =tagcolumn
  TAGS size :tcount
  TAGS (
    =tag
    tcount pred @tcount
    tag first :tagname
    tag last size :tagcount
    () =tagdata
    tagdata (
      tagname %tag
      tagcount %count 
    ) tap #tagdata
    count succ @count
    tagdata tagcolumn append #tagcolumn
    (count 4 == tcount 0 == or) 
    (
      ()
      tagcolumn %tags
      TAGCOLUMNS append #TAGCOLUMNS
      0 @count
      () #tagcolumn
    ) when
  ) foreach
) :prepare-tag-data

; Utility operator to format a timestamp into a date
(
  int "dddd, d MMMM yyyy" tformat
) :to-date


; Create the Tags page.
(
  ()
  "tags/index"  %id
  "tags.html"   %path
  ".html"       %ext
  "Tags"        %title
  "page"        %content-type
  TAGCOLUMNS    %tagcolumns
  dup "_tags" swap mustache %contents
  dup "page" swap mustache %contents
  output-fwrite
) :create-tags-page


; Create a page for a specific tag
(
  (quot) expect -> =tagdata
  tagdata first :tag
  tagdata last  =articles
  articles 
  articles (
    ((/timestamp swap /timestamp >) sort)
    ((dup /timestamp to-date %date) map)
  ) tap #articles
  ()
  "tags/$1/index" (tag) => %  %id
  "tags/$1.html"  (tag) => %  %path 
  tag                         %tag
  ".html"                     %ext
  "page"                      %content-type
  "Tag: $1" (tag) => %        %title
  articles                    %articles
  articles size               %count
  dup "_tag" swap mustache    %contents
  dup "page" swap mustache    %contents
  output-fwrite
) :create-tag-page



; Group articles by month
;(
;  (dict) expect -> =article
;  article /timestamp :ts
;  ts "dddd, d MMMM yyyy" tformat :date 
;  ts "yyyyMM" tformat :archive
;  ts "MMMM yyyy" tformat :month
;  (ARCHIVES archive dhas?)
;  (
;
;  )
;  (
;
;  ) if
;) :process-timestamp


; Group articles by tags
(
  (dict) expect -> =content
  (content ?tags)
  (
    content /tags "|" split =tags
    tags (
      :tag
      (TAGS tag dhas?)
      (
        ; Add article to existing tag
        content ("id" "title" "timestamp") dpick =article
        TAGS tag dget =tagdata
        article tagdata append #tagdata
        TAGS tagdata tag dset #TAGS
      )
      (
        ; Create new tag
        content ("id" "title" "timestamp") dpick ' =article
        TAGS article tag dset #TAGS
      ) if
    ) foreach
  ) when
  content
) :process-tags

; Copy PDF files saved in asset folder
; to the corresponding article output folder.
(
  (dict) expect -> =asset
  asset /id :id
  id "^pdf\/(.+)$" search 1 get :name
  asset "output/articles/$1/$1" (name) => % %id #asset
  asset output-cp
) :copy-pdf-article-asset


; Process a content file applying the appropriate template
; and compiling markdown to HTML if necessary.
(
  (dict) expect -> =content
  content /id :id
  content /content-type :ct
  "page" :tpl
  (ct "article" ==) ("article" @tpl) when
  (id "index" ==) ("home" @tpl) when
  "" :page
  "" :contents
  content (
    (input-fread @contents content)
    ((/ext ".md" ==) (=temp contents temp markdown @contents temp) when)
    (contents %contents)
    (=temp tpl temp mustache @page temp)
    (page %contents)
    ((id "index" !=)("$1/index" (id) => % %id ".html" %ext) when)
  ) tap
) :process-content

;;;; MAIN ;;;;

contents (process-tags process-content output-fwrite) foreach
prepare-tag-data
create-tags-page
TAGS 'create-tag-page foreach


; Process all assets.
assets (
  dup
  (
    ((/id "^pdf\/" match) (copy-pdf-article-asset))
    ;((/ext ".css" match) (process-css-asset))
    ((true) (output-cp))
  ) case
) foreach
