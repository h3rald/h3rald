'hastysite import

{} :TAGS
{} :TAG-COLUMNS
{} :ARCHIVES
() :ARCHIVE-COLUMNS
() :ARTICLES
{} :HOME
() :PROJECTS


; Utility operator to format a timestamp into a date
(
  integer "dddd, d MMMM yyyy" tformat
) ^to-date

; Create articles page
(
  {}
  "articles/index"    %id
  "articles.html"     %path
  ".html"             %ext
  "Articles"          %title
  "page"              %content-type
  ARCHIVES dvalues (/code :a /code :b a b >) sort %archives
  ARCHIVE-COLUMNS   %archive-columns
  ; TODO: why processing twice??
  dup "_archives" swap mustache %contents
  dup "page" swap mustache :page
  "articles" page process-icons
  %contents
  output-fwrite
) ^create-articles-page

; Create the Projects page
(
  {}
  "projects/index"                                    %id
  "projects.html"                                     %path
  ".html"                                             %ext
  "Projects"                                          %title
  "page"                                              %content-type
  PROJECTS ('active dhas?) filter (/id swap /id <) sort     %active-projects
  PROJECTS ('active dhas? not) filter (/id swap /id <) sort %inactive-projects
  dup "projects" swap mustache :page
  "projects" page process-icons
  %contents
  output-fwrite
) ^create-projects-page


0 :count ;....

; Group articles by month
(
  (dict) expect -> :content
  (content 'timestamp dhas?)
  (
    content /timestamp :ts
    ts to-date :date 
    ts integer "yyyyMM" tformat :code
    ts integer "MMMM yyyy" tformat :month
    ts integer "MMMM-yyyy" tformat lowercase :id
    ; Add to articles
    content date %date @content
    content ARTICLES append @ARTICLES
    (ARCHIVES code dhas?)
    (
      ; Add article to existing archive
      content ("id" "title" "timestamp" "date") dpick :article
      ARCHIVES code dget :archivedata
      archivedata /articles :articles
      article articles append @articles
      archivedata articles %articles :archivedata
      ARCHIVES archivedata code dset @ARCHIVES
    )
    (
      ; Create new monthly archive
      content ("id" "title" "timestamp" "date") dpick :article
      {}
      month         %month
      code          %code
      article quote %articles
      id            %id
      :archive
      ARCHIVES archive code dset @ARCHIVES
    ) if
  ) when
  content
) ^process-timestamp

; Copy PDF files saved in asset folder
; to the corresponding article output folder.
(
  (dict) expect -> :asset
  asset /id :id
  id "^pdf\/(.+)$" search 1 get :name
  asset "output/articles/$1/$1" (name) => % %id @asset
  asset output-cp
) ^copy-pdf-article-asset

; Syntax highlighting
(
  symbol process-code
  (str :text ==> str :result)
  (
    "temp/highlight" :tmpfile
    "chroma $# --html --html-only --html-prevent-surrounding-pre" :cmd
    text "<pre>\s*<code[^>]*>([\s\S]+?)</code></pre>" (
      :match
      match 1 get :code
      ; Unescape HTML entities
      code "(&gt;|&lt;|&quot;|&amp;)" (
        :match
        match 1 get :ntt

        (ntt "&gt;" ==)
          (">")
        when
        (ntt "&lt;" ==)
          ("<")
        when
        (ntt "&quot;" ==)
          ("\"")
        when
        (ntt "&amp;" ==)
          ("&")
        when
      ) replace-apply @code
      code tmpfile fwrite
      "$#" (cmd) =% (tmpfile) =% run /output :out
      "<pre class=\"chroma\"><code>$#</code></pre>" (out) =%
    ) replace-apply @result
  )
) ::

; Process :icon: markup
(
  symbol process-icons
  (str :id str :text ==> str :result)
  ( 
    ; whitelist of common false positives for icon markup
    ("borrow", "http", "cakephp") :whitelist
    text ":([a-z]+[a-z0-9-]+):" (
      :match
      match 0 get :content
      match 1 get :icon
      "assets/images/entypo/$#.svg" (icon) =% :path
      (path file?)
        (
          path fread from-xml "svg" xquery :svgx
          ; Add title tag
          "<title>$#</title>" (icon) =% from-xml :svg-title
          svgx dup /children svg-title swap prepend %children @svgx
          ; Add role="img"
          svgx /attributes :svg-attrs
          svgx svg-attrs "img" %role %attributes @svgx
          svgx to-xml :svg
          "<span class=\"icon\">$#</span>" (svg) =% @content
        )
        (
          (whitelist icon in? not)
            ("$# - Icon not found: $#" (id icon) =% warn)
          when
        )
      if
      content
    ) replace-apply @result
  ) 
) ::

; Process a content file applying the appropriate template
; and compiling markdown to HTML if necessary.
(
  (dict) expect -> :content
  content /id :id
  content /content-type :ct
  "page" :tpl
  (ct "article" ==) ("article" @tpl) when
  (ct "project" ==) ("project" @tpl) when
  (id "index" ==) (content @HOME "home" @tpl) when
  "" :page
  "" :contents
  content input-fread @contents
  (content /ext ".md" ==) (contents content markdown @contents) when
  content contents %contents @content
  tpl content mustache @page
  id page process-icons @page
  id page process-code @page
  content page %contents @content
  (
      ((id "^(glyph|ruby-compendium)\/book" match?) ()) ;Do not add index.html
      ((id "index" !=)(
        content 
          "$1/index" (id) =% %id 
          ".html" %ext 
          ; ID must be preserved for links on home page.
          id %rawid
        @content
      ))
  ) case
  content
) ^process-content

; Process and generate home page
(
  ; Sort articles by timestamp
  ARTICLES (/timestamp swap /timestamp >) sort @ARTICLES
  ARTICLES first        :latest
  ARTICLES 1 5 slice    :recents
  ; Process summary
  latest input-fread "(?ms)(.+)?<hr" search 1 get latest markdown :summary
  latest summary %summary @latest
  latest dup /timestamp to-date %date @latest
  HOME
  latest %latest
  recents %recents
  ;tags %tags
  dup "home" swap mustache :page
  "home" page process-icons
  %contents
  output-fwrite
) ^generate-home

;; Pre-process CSS assets
(
  (dict) expect -> :meta
  "" :contents
  meta (
    (input-fread @contents meta)
    (:temp contents @contents temp)
    (contents %contents)
  ) tap
  output-fwrite
) ^process-css-asset

;;;;; MAIN ;;;;;

;#|
; Process all contents
contents (
  :content
  (((content 'draft dhas? not) (content 'content-type dhas?)) &&)
  (
    content /id :id
    (content /content-type "project" ==) (content PROJECTS append @PROJECTS) when
    content
    "." print!
    process-timestamp 
    process-content 
    @content 
    (id "index" !=) (content output-fwrite) when
  ) when
) foreach
"" puts!

; Create aggregator pages
create-projects-page
create-articles-page

; Generate home page
generate-home
;|#

; Process all assets.
assets (
  dup
  (
    ((/id "^pdf\/" match?) (copy-pdf-article-asset))
    ((/ext ".css" match?) (process-css-asset))
    ((true) (output-cp))
  ) case
) foreach
