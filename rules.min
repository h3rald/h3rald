'hastysite import

() =TAGS
() =TAG-COLUMNS
() =ARCHIVES
() =ARCHIVE-COLUMNS


; Populates the ARCHIVE-COLUMNS array containing tags in groups
; of four, suitable for the creation of the archives page.
(
  ARCHIVES dsort reverse #ARCHIVES
  0 :count
  () =archcolumn
  ARCHIVES size :acount
  ARCHIVES (
    =archive
    acount pred @acount
    archive last =arch
    arch /id            :archid
    arch /articles size :archcount
    arch /month         :month
    ()
    archcount %count 
    archid    %id
    month     %month
    =archdata
    count succ @count
    archdata archcolumn append #archcolumn
    (count 4 == acount 0 == or) 
    (
      ()
      archcolumn %archives
      ARCHIVE-COLUMNS append #ARCHIVE-COLUMNS
      0 @count
      () #archcolumn
    ) when
  ) foreach
) :prepare-archive-data

; Populates the TAG-COLUMNS array containing tags in groups
; of four, suitable for the creation of the tags page.
(
  TAGS dsort #TAGS
  0 :count
  () =tagcolumn
  TAGS size :tcount
  TAGS (
    =tag
    tcount pred @tcount
    tag first :tagname
    tag last size :tagcount
    ()
    tagname %tag
    tagcount %count 
    =tagdata
    count succ @count
    tagdata tagcolumn append #tagcolumn
    (count 4 == tcount 0 == or) 
    (
      ()
      tagcolumn %tags
      TAG-COLUMNS append #TAG-COLUMNS
      0 @count
      () #tagcolumn
    ) when
  ) foreach
) :prepare-tag-data

; Utility operator to format a timestamp into a date
(
  int "dddd, d MMMM yyyy" tformat
) :to-date


; Create the Archives page.
(
  ()
  "archives/index"  %id
  "archives.html"   %path
  ".html"           %ext
  "Archives"        %title
  "page"            %content-type
  ARCHIVE-COLUMNS   %archive-columns
  dup "_archives" swap mustache %contents
  dup "page" swap mustache %contents
  output-fwrite
) :create-archives-page


; Create the Tags page.
(
  ()
  "tags/index"  %id
  "tags.html"   %path
  ".html"       %ext
  "Tags"        %title
  "page"        %content-type
  TAG-COLUMNS    %tag-columns
  dup "_tags" swap mustache %contents
  dup "page" swap mustache %contents
  output-fwrite
) :create-tags-page


; Create a page for a specific tag
(
  (quot) expect -> =tagdata
  tagdata first :tag
  tagdata last  =articles
  articles 
  articles (
    ((/timestamp swap /timestamp >) sort)
    ((dup /timestamp to-date %date) map)
  ) tap #articles
  ()
  "tags/$1/index" (tag) => %  %id
  "tags/$1.html"  (tag) => %  %path 
  tag                         %tag
  ".html"                     %ext
  "page"                      %content-type
  "Tag: $1" (tag) => %        %title
  articles                    %articles
  articles size               %count
  dup "_tag" swap mustache    %contents
  dup "page" swap mustache    %contents
  output-fwrite
) :create-tag-page



; Group articles by month
(
  (dict) expect -> =content
  (content ?timestamp)
  (
    content /timestamp :ts
    ts to-date :date 
    ts int "yyyyMM" tformat :code
    ts int "MMMM yyyy" tformat :month
    ts int "MMMM-yyyy" tformat lowercase :id
    (ARCHIVES code dhas?)
    (
      ; Add article to existing archive
      content ("id" "title" "timestamp") dpick =article
      ARCHIVES code dget =archivedata
      archivedata /articles =articles
      article articles append #articles
      archivedata articles %articles #archivedata
      ARCHIVES archivedata code dset #ARCHIVES
    )
    (
      ; Create new monthly archive
      content ("id" "title" "timestamp") dpick ' =article
      ()
      month   %month
      article %articles
      id      %id
      =archive
      ARCHIVES archive code dset #ARCHIVES
    ) if
  ) when
  content
) :process-timestamp


; Group articles by tags
(
  (dict) expect -> =content
  (content ?tags)
  (
    content /tags "|" split =tags
    tags (
      :tag
      (TAGS tag dhas?)
      (
        ; Add article to existing tag
        content ("id" "title" "timestamp") dpick =article
        TAGS tag dget =tagdata
        article tagdata append #tagdata
        TAGS tagdata tag dset #TAGS
      )
      (
        ; Create new tag
        content ("id" "title" "timestamp") dpick ' =article
        TAGS article tag dset #TAGS
      ) if
    ) foreach
  ) when
  content
) :process-tags

; Copy PDF files saved in asset folder
; to the corresponding article output folder.
(
  (dict) expect -> =asset
  asset /id :id
  id "^pdf\/(.+)$" search 1 get :name
  asset "output/articles/$1/$1" (name) => % %id #asset
  asset output-cp
) :copy-pdf-article-asset


; Process a content file applying the appropriate template
; and compiling markdown to HTML if necessary.
(
  (dict) expect -> =content
  content /id :id
  content /content-type :ct
  "page" :tpl
  (ct "article" ==) ("article" @tpl) when
  (id "index" ==) ("home" @tpl) when
  "" :page
  "" :contents
  content (
    (input-fread @contents content)
    ((/ext ".md" ==) (=temp contents temp markdown @contents temp) when)
    (contents %contents)
    (=temp tpl temp mustache @page temp)
    (page %contents)
    ((id "index" !=)("$1/index" (id) => % %id ".html" %ext) when)
  ) tap
) :process-content

;;;; MAIN ;;;;

contents (
  process-tags 
  process-timestamp 
  process-content
  output-fwrite
) foreach

prepare-tag-data
create-tags-page
TAGS 'create-tag-page foreach

prepare-archive-data
create-archives-page


; Process all assets.
assets (
  dup
  (
    ((/id "^pdf\/" match) (copy-pdf-article-asset))
    ;((/ext ".css" match) (process-css-asset))
    ((true) (output-cp))
  ) case
) foreach
