'hastysite import

() =TAGS
() =TAG-COLUMNS
() =ARCHIVES
() =ARCHIVE-COLUMNS
() =ARTICLES
() =HOME


; Populates the ARCHIVE-COLUMNS array containing tags in groups
; of four, suitable for the creation of the archives page.
;(
;  ARCHIVES dsort reverse #ARCHIVES
;  0 :count
;  () =archcolumn
;  ARCHIVES size :acount
;  ARCHIVES (
;    =archive
;    acount pred @acount
;    archive last =arch
;    arch /id            :archid
;    arch /articles size :archcount
;    arch /month         :month
;    ()
;    archcount %count 
;    archid    %id
;    month     %month
;    =archdata
;    count succ @count
;    archdata archcolumn append #archcolumn
;    (count 4 == acount 0 == or) 
;    (
;      ()
;      archcolumn %archives
;      ARCHIVE-COLUMNS append #ARCHIVE-COLUMNS
;      0 @count
;      () #archcolumn
;    ) when
;  ) foreach
;) :prepare-archive-data


; Populates the TAG-COLUMNS array containing tags in groups
; of four, suitable for the creation of the tags page.
;(
;  TAGS dsort #TAGS
;  0 :count
;  () =tagcolumn
;  TAGS size :tcount
;  TAGS (
;    =tag
;    tcount pred @tcount
;    tag first :tagname
;    tag last size :tagcount
;    ()
;    tagname %tag
;    tagcount %count 
;    =tagdata
;    count succ @count
;    tagdata tagcolumn append #tagcolumn
;    (count 4 == tcount 0 == or) 
;    (
;      ()
;      tagcolumn %tags
;      TAG-COLUMNS append #TAG-COLUMNS
;      0 @count
;      () #tagcolumn
;    ) when
;  ) foreach
;) :prepare-tag-data


; Utility operator to format a timestamp into a date
(
  int "dddd, d MMMM yyyy" tformat
) :to-date


; Create the Archives page.
(
  ()
  "archives/index"    %id
  "archives.html"     %path
  ".html"             %ext
  "Archives"          %title
  "page"              %content-type
  ARCHIVES 'last map (/code :a /code :b a b >) sort %archives
  ;ARCHIVE-COLUMNS   %archive-columns
  dup "_archives" swap mustache %contents
  dup "page" swap mustache %contents
  output-fwrite
) :create-archives-page


; Create the Tags page.
;(
;  ()
;  "tags/index"  %id
;  "tags.html"   %path
;  ".html"       %ext
;  "Tags"        %title
;  "page"        %content-type
;  TAG-COLUMNS   %tag-columns
;  dup "_tags" swap mustache %contents
;  dup "page" swap mustache %contents
;  output-fwrite
;) :create-tags-page


; Create a page for a specific archive
;(
;  (quot) expect -> =archive
;  archive last =archdata
;  archdata /month     :month
;  archdata /articles  =articles
;  archdata /id        :id
;  articles 
;  articles (
;    ((/timestamp swap /timestamp >) sort)
;    ((dup /timestamp to-date %date) map)
;  ) tap #articles
;  articles size :count
;  (count 1 ==)
;  ("1 article was written") 
;  ("$1 articles were written" (count) => %) 
;  if :articles-written
;  ()
;  "archives/$1/index" (id) => %   %id
;  "archives/$1.html"  (id) => %   %path 
;  ".html"                         %ext
;  "page"                          %content-type
;  "Archive: $1" (month) => %      %title
;  month                           %month
;  articles-written                %articles-written
;  articles                        %articles
;  dup "_archive" swap mustache    %contents
;  dup "page" swap mustache        %contents
;  output-fwrite
;) :create-archive-page


; Create a page for a specific tag
;(
;  (quot) expect -> =tagdata
;  tagdata first :tag
;  tagdata last  =articles
;  articles 
;  articles (
;    ((/timestamp swap /timestamp >) sort)
;    ((dup /timestamp to-date %date) map)
;  ) tap #articles
;  articles size :count
;  (count 1 ==)
;  ("1 article is tagged") 
;  ("$1 articles are tagged" (count) => %) 
;  if :articles-tagged
;  ()
;  "tags/$1/index" (tag) => %  %id
;  "tags/$1.html"  (tag) => %  %path 
;  tag                         %tag
;  ".html"                     %ext
;  "page"                      %content-type
;  "Tag: $1" (tag) => %        %title
;  articles-tagged             %articles-tagged
;  articles                    %articles
;  dup "_tag" swap mustache    %contents
;  dup "page" swap mustache    %contents
;  output-fwrite
;) :create-tag-page

; Group articles by month
(
  (dict) expect -> =content
  (content ?timestamp)
  (
    content /timestamp :ts
    ts to-date :date 
    ts int "yyyyMM" tformat :code
    ts int "MMMM yyyy" tformat :month
    ts int "MMMM-yyyy" tformat lowercase :id
    ; Add to articles
    content date %date #content
    content ARTICLES  append #ARTICLES
    (ARCHIVES code dhas?)
    (
      ; Add article to existing archive
      content ("id" "title" "timestamp" "date") dpick =article
      ARCHIVES code dget =archivedata
      archivedata /articles =articles
      article articles append #articles
      archivedata articles %articles #archivedata
      ARCHIVES archivedata code dset #ARCHIVES
    )
    (
      ; Create new monthly archive
      content ("id" "title" "timestamp" "date") dpick ' =article
      ()
      month   %month
      code    %code
      article %articles
      id      %id
      =archive
      ARCHIVES archive code dset #ARCHIVES
    ) if
  ) when
  content
) :process-timestamp


; Group articles by tags
(
  (dict) expect -> =content
  (content ?tags)
  (
    content /tags "|" split =tags
    tags (
      :tag
      (TAGS tag dhas?)
      (
        ; Add article to existing tag
        content ("id" "title" "timestamp") dpick =article
        TAGS tag dget =tagdata
        article tagdata append #tagdata
        TAGS tagdata tag dset #TAGS
      )
      (
        ; Create new tag
        content ("id" "title" "timestamp") dpick ' =article
        TAGS article tag dset #TAGS
      ) if
    ) foreach
  ) when
  content
) :process-tags


; Copy PDF files saved in asset folder
; to the corresponding article output folder.
(
  (dict) expect -> =asset
  asset /id :id
  id "^pdf\/(.+)$" search 1 get :name
  asset "output/articles/$1/$1" (name) => % %id #asset
  asset output-cp
) :copy-pdf-article-asset


; Process a content file applying the appropriate template
; and compiling markdown to HTML if necessary.
(
  (dict) expect -> =content
  content /id :id
  content /content-type :ct
  "page" :tpl
  (ct "article" ==) ("article" @tpl) when
  (id "index" ==) (content #HOME "home" @tpl) when
  "" :page
  "" :contents
  content (
    (input-fread @contents content)
    ((/ext ".md" ==) (=temp contents temp markdown @contents temp) when)
    (contents %contents)
    (=temp tpl temp mustache @page temp)
    (page %contents)
    ((
      ((id "^(glyph|ruby-compendium)\/book" match) ()) ;Do not add index.html
      ((id "index" !=)("$1/index" (id) => % %id ".html" %ext))
    ) case)
  ) tap
) :process-content


; Process and generate home page
(
  ; Sort articles by timestamp
  ARTICLES (/timestamp swap /timestamp >) sort #ARTICLES
  ARTICLES first        =latest
  ARTICLES 1 4 slice    =recents
  ; Process summary
  latest input-fread "/(.+)?<hr/ms" regex 1 get latest markdown :summary
  latest summary %summary #latest
  latest dup /timestamp to-date %date #latest
  ; Process top tags
  TAGS (
    dup first :tag
    last size :total
    (tag total) => 
  ) map
  (last swap last >) sort 
  0 9 slice
  (
    =data
    ()
    data first %tag
    data last  %total
  ) map
  =tags
  HOME (
    (latest   %latest)
    (recents  %recents)
    (tags     %tags)
    (=temp temp "home" temp mustache %contents)
    (output-fwrite)
  ) tap!
) :generate-home

;;;;; MAIN ;;;;;

; Process all contents
contents (
  =content
  content /id :id
  content
  process-tags 
  process-timestamp 
  process-content
  (id "index" !=) 'output-fwrite when
) foreach

; Generate tag pages
;prepare-tag-data
;create-tags-page
;TAGS 'create-tag-page foreach

; Generate archive pages
;prepare-archive-data
create-archives-page
;ARCHIVES 'create-archive-page foreach

; Generate home page
generate-home



; Process all assets.
assets (
  dup
  (
    ((/id "^pdf\/" match) (copy-pdf-article-asset))
    ((true) (output-cp))
  ) case
) foreach
